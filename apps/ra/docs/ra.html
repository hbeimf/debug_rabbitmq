<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module ra</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module ra</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>The primary module for interacting with ra servers and clusters.


<h2><a name="description">Description</a></h2>The primary module for interacting with ra servers and clusters.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-cluster_name">cluster_name()</a></h3>
<p><pre>cluster_name() = <a href="#type-ra_cluster_name">ra_cluster_name()</a></pre></p>


<h3 class="typedecl"><a name="type-environment_param">environment_param()</a></h3>
<p><pre>environment_param() = 
    {data_dir, <a href="/Users/nkarl/code/rabbitmq/kernel/doc/file.html#type-filename">file:filename()</a>} |
    {wal_data_dir, <a href="/Users/nkarl/code/rabbitmq/kernel/doc/file.html#type-filename">file:filename()</a>} |
    {segment_max_entries, non_neg_integer()} |
    {wal_max_size_bytes, non_neg_integer()} |
    {wal_compute_checksums, boolean()} |
    {wal_write_strategy, default | o_sync}</pre></p>


<h3 class="typedecl"><a name="type-index">index()</a></h3>
<p><pre>index() = <a href="#type-ra_index">ra_index()</a></pre></p>


<h3 class="typedecl"><a name="type-query_fun">query_fun()</a></h3>
<p><pre>query_fun() = 
    fun((term()) -&gt; term()) |
    {M :: module(), F :: atom(), A :: list()}</pre></p>


<h3 class="typedecl"><a name="type-ra_cmd_ret">ra_cmd_ret()</a></h3>
<p><pre>ra_cmd_ret() = <a href="ra_server_proc.html#type-ra_cmd_ret">ra_server_proc:ra_cmd_ret()</a></pre></p>


<h3 class="typedecl"><a name="type-server_id">server_id()</a></h3>
<p><pre>server_id() = <a href="#type-ra_server_id">ra_server_id()</a></pre></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the ra application.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Starts the ra application.</td></tr>
<tr><td valign="top"><a href="#start_in-1">start_in/1</a></td><td>Starts the ra application with a provided data directory.</td></tr>
<tr><td valign="top"><a href="#restart_server-1">restart_server/1</a></td><td>Restarts a previously successfully started ra server in the default system.</td></tr>
<tr><td valign="top"><a href="#restart_server-2">restart_server/2</a></td><td>Restarts a previously successfully started ra server.</td></tr>
<tr><td valign="top"><a href="#restart_server-3">restart_server/3</a></td><td>Restarts a previously successfully started ra server.</td></tr>
<tr><td valign="top"><a href="#stop_server-1">stop_server/1</a></td><td>Stops a ra server in the default system.</td></tr>
<tr><td valign="top"><a href="#stop_server-2">stop_server/2</a></td><td>Stops a ra server.</td></tr>
<tr><td valign="top"><a href="#force_delete_server-2">force_delete_server/2</a></td><td>Deletes a ra server
  The server is forcefully deleted.</td></tr>
<tr><td valign="top"><a href="#start_or_restart_cluster-4">start_or_restart_cluster/4</a></td><td>Starts or restarts a ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_or_restart_cluster-5">start_or_restart_cluster/5</a></td><td>Same as <code>start_or_restart_cluster/4</code> but accepts a custom timeout.</td></tr>
<tr><td valign="top"><a href="#start_cluster-4">start_cluster/4</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_cluster-2">start_cluster/2</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_cluster-3">start_cluster/3</a></td><td>Same as <code>start_cluster/1</code> but accepts a custom timeout.</td></tr>
<tr><td valign="top"><a href="#start_server-5">start_server/5</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_server-1">start_server/1</a></td><td>Starts a ra server in the default system.</td></tr>
<tr><td valign="top"><a href="#start_server-2">start_server/2</a></td><td>Starts a ra server.</td></tr>
<tr><td valign="top"><a href="#delete_cluster-1">delete_cluster/1</a></td><td>Deletes a ra cluster in an orderly fashion.</td></tr>
<tr><td valign="top"><a href="#delete_cluster-2">delete_cluster/2</a></td><td>Same as <code>delete_cluster/1</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#add_member-2">add_member/2</a></td><td>Add a ra server id to a ra cluster's membership configuration.</td></tr>
<tr><td valign="top"><a href="#add_member-3">add_member/3</a></td><td>Same as <code>add_member/2</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#remove_member-2">remove_member/2</a></td><td>Removes a server from the cluster's membership configuration.</td></tr>
<tr><td valign="top"><a href="#remove_member-3">remove_member/3</a></td><td>Same as <code>remove_member/2</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#trigger_election-1">trigger_election/1</a></td><td>Makes the server to enter a pre-vote state and attempt to become the leader.</td></tr>
<tr><td valign="top"><a href="#trigger_election-2">trigger_election/2</a></td><td>Same as <code>trigger_election/2</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-3">leave_and_terminate/3</a></td><td>A safe way to remove an active server from its cluster.</td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-4">leave_and_terminate/4</a></td><td>Same as <code>leave_and_terminate/2</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#leave_and_delete_server-3">leave_and_delete_server/3</a></td><td>A safe way to remove an active server from its cluster.</td></tr>
<tr><td valign="top"><a href="#leave_and_delete_server-4">leave_and_delete_server/4</a></td><td>Same as <code>leave_and_delete_server/2</code> but also accepts a timeout.</td></tr>
<tr><td valign="top"><a href="#new_uid-1">new_uid/1</a></td><td>generates a random uid using the provided source material for the first
  6 characters.</td></tr>
<tr><td valign="top"><a href="#overview-0">overview/0</a></td><td>Returns a map of overview data of the default Ra system on the current Erlang
  node.</td></tr>
<tr><td valign="top"><a href="#overview-1">overview/1</a></td><td>Returns a map of overview data of the Ra system on the current Erlang
  node.</td></tr>
<tr><td valign="top"><a href="#process_command-3">process_command/3</a></td><td>Submits a command to a ra server.</td></tr>
<tr><td valign="top"><a href="#process_command-2">process_command/2</a></td><td>Same as <code>process_command/3</code> with the default timeout of 5000 ms.</td></tr>
<tr><td valign="top"><a href="#pipeline_command-4">pipeline_command/4</a></td><td>Submits a command to the ra server using a gen_statem:cast, passing  
an optional process-scoped term as correlation identifier.</td></tr>
<tr><td valign="top"><a href="#pipeline_command-3">pipeline_command/3</a></td><td>Same as <code>pipeline_command/4</code> but uses a hardcoded priority of <code>low</code>.</td></tr>
<tr><td valign="top"><a href="#pipeline_command-2">pipeline_command/2</a></td><td>Sends a command to the ra server using a gen_statem:cast without
  any correlation identifier.</td></tr>
<tr><td valign="top"><a href="#local_query-2">local_query/2</a></td><td>Query the machine state on any available server.</td></tr>
<tr><td valign="top"><a href="#local_query-3">local_query/3</a></td><td>Same as <code>local_query/2</code> but accepts a custom timeout.</td></tr>
<tr><td valign="top"><a href="#leader_query-2">leader_query/2</a></td><td>Query the machine state on the current leader node.</td></tr>
<tr><td valign="top"><a href="#leader_query-3">leader_query/3</a></td><td>Same as <code>leader_query/2</code> but accepts a custom timeout.</td></tr>
<tr><td valign="top"><a href="#consistent_query-2">consistent_query/2</a></td><td>Query the state machine with a consistency guarantee.</td></tr>
<tr><td valign="top"><a href="#consistent_query-3">consistent_query/3</a></td><td>Same as <code>consistent_query/2</code> but accepts a custom timeout.</td></tr>
<tr><td valign="top"><a href="#members-1">members/1</a></td><td>Returns a list of cluster members.</td></tr>
<tr><td valign="top"><a href="#members-2">members/2</a></td><td>Returns a list of cluster members.</td></tr>
<tr><td valign="top"><a href="#initial_members-1">initial_members/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#initial_members-2">initial_members/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#transfer_leadership-2">transfer_leadership/2</a></td><td>Transfers leadership from the leader to a follower.</td></tr>
<tr><td valign="top"><a href="#aux_command-2">aux_command/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#cast_aux_command-2">cast_aux_command/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#register_external_log_reader-1">register_external_log_reader/1</a></td><td>Registers an external log reader.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><pre>start() -&gt; ok</pre></p>
<p> </p>
</div><p>Starts the ra application.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><pre>start(Params :: [<a href="#type-environment_param">environment_param()</a>]) -&gt;
         {ok, [Started]} | {error, term()}</pre>
<ul class="definitions"><li><pre>Started = term()</pre></li></ul></p>
<p> </p>
</div><p>Starts the ra application.
  If the application is running it will be stopped and restarted.</p>

<h3 class="function"><a name="start_in-1">start_in/1</a></h3>
<div class="spec">
<p><pre>start_in(DataDir :: <a href="/Users/nkarl/code/rabbitmq/kernel/doc/file.html#type-filename">file:filename()</a>) -&gt;
            {ok, [Started]} | {error, term()}</pre>
<ul class="definitions"><li><pre>Started = term()</pre></li></ul></p>
<p> </p>
</div><p>Starts the ra application with a provided data directory.
  The same as ra:start([{data_dir, dir}])
  If the application is running it will be stopped and restarted.</p>

<h3 class="function"><a name="restart_server-1">restart_server/1</a></h3>
<div class="spec">
<p><pre>restart_server(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt; ok | {error, term()}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, Error}</code> where error can be
  <code>not_found</code>, <code>system_not_started</code> or <code>name_not_registered</code> when the
  ra server has never before been started on the Erlang node.
  DEPRECATED: use restart_server/2</p>
</div><p>Restarts a previously successfully started ra server in the default system</p>

<h3 class="function"><a name="restart_server-2">restart_server/2</a></h3>
<div class="spec">
<p><pre>restart_server(System :: atom(), ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                  ok | {error, term()}</pre></p>
<p><tt>System</tt>: the system identifier<br>
<tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, Error}</code> where error can be
  <code>not_found</code> or <code>name_not_registered</code> when the ra server has never before
  been started on the Erlang node.</p>
</div><p>Restarts a previously successfully started ra server</p>

<h3 class="function"><a name="restart_server-3">restart_server/3</a></h3>
<div class="spec">
<p><pre>restart_server(System :: atom(),
               ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
               AddConfig :: <a href="ra_server.html#type-mutable_config">ra_server:mutable_config()</a>) -&gt;
                  ok | {error, term()}</pre></p>
<p><tt>System</tt>: the system identifier<br>
<tt>ServerId</tt>: the ra_server_id() of the server<br>
<tt>AddConfig</tt>: additional config parameters to be merged into the
  original config.<br>
</p>
<p>returns: <code>{ok | error, Error}</code> where error can be
  <code>not_found</code> or <code>name_not_registered</code> when the ra server has never before
  been started on the Erlang node.</p>
</div><p>Restarts a previously successfully started ra server</p>

<h3 class="function"><a name="stop_server-1">stop_server/1</a></h3>
<div class="spec">
<p><pre>stop_server(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
               ok | {error, nodedown | system_not_started}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code>
  DEPRECATED: use stop_server/2</p>
</div><p>Stops a ra server in the default system</p>

<h3 class="function"><a name="stop_server-2">stop_server/2</a></h3>
<div class="spec">
<p><pre>stop_server(System :: atom(), ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
               ok | {error, nodedown | system_not_started}</pre></p>
<p><tt>System</tt>: the system name<br>
<tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Stops a ra server</p>

<h3 class="function"><a name="force_delete_server-2">force_delete_server/2</a></h3>
<div class="spec">
<p><pre>force_delete_server(System :: atom(), ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                       ok | {error, term()} | {badrpc, term()}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>ok | {error, nodedown} | {badrpc, Reason}</code></p>
</div><p>Deletes a ra server
  The server is forcefully deleted.</p>

<h3 class="function"><a name="start_or_restart_cluster-4">start_or_restart_cluster/4</a></h3>
<div class="spec">
<p><pre>start_or_restart_cluster(System :: atom(),
                         ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
                         Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
                         ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                            {ok,
                             [<a href="#type-ra_server_id">ra_server_id()</a>],
                             [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                            {error, cluster_not_formed}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>Machine</tt>: The <a docgen-rel="seemfa" docgen-href="ra_machine#machine/0" href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
<tt>ServerIds</tt>: The list of ra server ids.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a docgen-rel="seemfa" docgen-href="#start_server/1" href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If there was no existing cluster and a new cluster could not be formed
  any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts or restarts a ra cluster.
 </p>

<h3 class="function"><a name="start_or_restart_cluster-5">start_or_restart_cluster/5</a></h3>
<div class="spec">
<p><pre>start_or_restart_cluster(System :: atom(),
                         ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
                         Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
                         RemServers :: [<a href="#type-ra_server_id">ra_server_id()</a>],
                         Timeout :: non_neg_integer()) -&gt;
                            {ok,
                             [<a href="#type-ra_server_id">ra_server_id()</a>],
                             [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                            {error, cluster_not_formed}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>Machine</tt>: The <a docgen-rel="seemfa" docgen-href="ra_machine#machine/0" href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
<tt>Timeout</tt>: The time to wait for any server to restart or start<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a docgen-rel="seemfa" docgen-href="#start_server/1" href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If there was no existing cluster and a new cluster could not be formed
  any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Same as <code>start_or_restart_cluster/4</code> but accepts a custom timeout.</p>
<p><b>See also:</b> <a href="#start_or_restart_cluster-3">start_or_restart_cluster/3</a>.</p>

<h3 class="function"><a name="start_cluster-4">start_cluster/4</a></h3>
<div class="spec">
<p><pre>start_cluster(System :: atom(),
              ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
              Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
              ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                 {ok, [<a href="#type-ra_server_id">ra_server_id()</a>], [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                 {error, cluster_not_formed}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>Machine</tt>: The <a docgen-rel="seemfa" docgen-href="ra_machine#machine/0" href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
<tt>ServerIds</tt>: The list of ra server ids.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a docgen-rel="seemfa" docgen-href="#start_server/1" href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts a new distributed ra cluster.
 </p>

<h3 class="function"><a name="start_cluster-2">start_cluster/2</a></h3>
<div class="spec">
<p><pre>start_cluster(System :: atom(),
              ServerConfigs :: [<a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>]) -&gt;
                 {ok, [<a href="#type-ra_server_id">ra_server_id()</a>], [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                 {error, cluster_not_formed}</pre></p>
<p><tt>ServerConfigs</tt>: a list of initial server configurations<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a docgen-rel="seemfa" docgen-href="#start_server/1" href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts a new distributed ra cluster.
 </p>

<h3 class="function"><a name="start_cluster-3">start_cluster/3</a></h3>
<div class="spec">
<p><pre>start_cluster(System :: atom(),
              ServerConfigs :: [<a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>],
              Timeout :: non_neg_integer()) -&gt;
                 {ok, [<a href="#type-ra_server_id">ra_server_id()</a>], [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                 {error, cluster_not_formed}</pre></p>
<p><tt>ServerConfigs</tt>: a list of initial server configurations<br>
<tt>Timeout</tt>: the timeout to use<br>
</p>
</div><p>Same as <code>start_cluster/1</code> but accepts a custom timeout.</p>

<h3 class="function"><a name="start_server-5">start_server/5</a></h3>
<div class="spec">
<p><pre>start_server(System :: atom(),
             ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
             ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
             Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
             ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                ok | {error, term()}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>ServerId</tt>: the ra_server_id() of the server<br>
<tt>Machine</tt>: The <a docgen-rel="seemfa" docgen-href="ra_machine#machine/0" href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a docgen-rel="seemfa" docgen-href="#start_server/1" href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts a new distributed ra cluster.</p>
<p><b>See also:</b> <a href="#start_server-1">start_server/1</a>.</p>

<h3 class="function"><a name="start_server-1">start_server/1</a></h3>
<div class="spec">
<p><pre>start_server(Conf :: <a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>) -&gt;
                ok | {error, term()}</pre></p>
<p><tt>Conf</tt>: a ra_server_config() configuration map.<br>
</p>
<p>returns: <code>{ok | error, Error}</code>
  DEPRECATED: use start_server/2</p>
</div><p>Starts a ra server in the default system</p>

<h3 class="function"><a name="start_server-2">start_server/2</a></h3>
<div class="spec">
<p><pre>start_server(System :: atom(),
             Conf :: <a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>) -&gt;
                ok | {error, term()}</pre></p>
<p><tt>Conf</tt>: a ra_server_config() configuration map.<br>
</p>
<p>returns: <code>{ok | error, Error}</code></p>
</div><p>Starts a ra server</p>

<h3 class="function"><a name="delete_cluster-1">delete_cluster/1</a></h3>
<div class="spec">
<p><pre>delete_cluster(ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                  {ok, <a href="#type-ra_server_id">ra_server_id()</a>} | {error, term()}</pre></p>
<p><tt>ServerIds</tt>: the ra_server_ids of the cluster<br>
</p>
<p>returns: <code>{{ok, Leader} | error, nodedown}</code></p>
</div><p>Deletes a ra cluster in an orderly fashion.
  This function commits an end of life command which after each server applies
  it will cause that server to shut down and delete all its data.
  The leader will stay up until it has successfully replicated the end of life
  command to all servers after which it too will shut down and delete all of its
  data.</p>

<h3 class="function"><a name="delete_cluster-2">delete_cluster/2</a></h3>
<div class="spec">
<p><pre>delete_cluster(ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>],
               Timeout :: timeout()) -&gt;
                  {ok, Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} | {error, term()}</pre></p>
<p> </p>
</div><p>Same as <code>delete_cluster/1</code> but also accepts a timeout.</p>
<p><b>See also:</b> <a href="#delete_cluster-1">delete_cluster/1</a>.</p>

<h3 class="function"><a name="add_member-2">add_member/2</a></h3>
<div class="spec">
<p><pre>add_member(ServerLoc :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
           ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
              <a href="#type-ra_cmd_ret">ra_cmd_ret()</a> |
              {error, already_member} |
              {error, cluster_change_not_permitted}</pre></p>
<p><tt>ServerLoc</tt>: the ra server or servers to try to send the command to<br>
<tt>ServerId</tt>: the ra server id of the new server.<br>
</p>
</div><p>Add a ra server id to a ra cluster's membership configuration.
  This commits a join command to the leader log. After this has been replicated
  the leader will start replicating entries to the new server.
  This function returns after appending the command to the log.
  New node does not have to be running at the time of addition but it is expected
  to come online in a reasonable amount of time. A new member that's been
  announced to its new cluster but taking a long time to start will
  affect said cluster's availability characteristics (by increasing quorum node count).
 </p>

<h3 class="function"><a name="add_member-3">add_member/3</a></h3>
<div class="spec">
<p><pre>add_member(ServerLoc :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
           ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
           Timeout :: timeout()) -&gt;
              <a href="#type-ra_cmd_ret">ra_cmd_ret()</a> |
              {error, already_member} |
              {error, cluster_change_not_permitted}</pre></p>
<p> </p>
</div><p>Same as <code>add_member/2</code> but also accepts a timeout.</p>
<p><b>See also:</b> <a href="#add_member-2">add_member/2</a>.</p>

<h3 class="function"><a name="remove_member-2">remove_member/2</a></h3>
<div class="spec">
<p><pre>remove_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
              ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                 <a href="#type-ra_cmd_ret">ra_cmd_ret()</a> |
                 {error, not_member} |
                 {error, cluster_change_not_permitted}</pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to<br>
<tt>ServerId</tt>: the ra server id of the server to remove<br>
</p>
</div><p><p>Removes a server from the cluster's membership configuration.  
This function returns after appending a cluster membership change  
command to the log.</p>
 
  After a server is removed from its cluster and the membership change is replicated,
  it would reject any commands it's asked to process.
 </p>
<p><b>See also:</b> <a href="#add_member-2">add_member/2</a>, <a href="#leave_and_delete_server-2">leave_and_delete_server/2</a>, <a href="#leave_and_terminate-2">leave_and_terminate/2</a>, <a href="#remove_member-3">remove_member/3</a>.</p>

<h3 class="function"><a name="remove_member-3">remove_member/3</a></h3>
<div class="spec">
<p><pre>remove_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
              ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
              Timeout :: timeout()) -&gt;
                 <a href="#type-ra_cmd_ret">ra_cmd_ret()</a> |
                 {error, not_member} |
                 {error, cluster_change_not_permitted}</pre></p>
<p> </p>
</div><p>Same as <code>remove_member/2</code> but also accepts a timeout.</p>
<p><b>See also:</b> <a href="#remove_member-2">remove_member/2</a>.</p>

<h3 class="function"><a name="trigger_election-1">trigger_election/1</a></h3>
<div class="spec">
<p><pre>trigger_election(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt; ok</pre></p>
<p><tt>ServerId</tt>: the ra server id of the server to trigger the election on.<br>
</p>
</div><p>Makes the server to enter a pre-vote state and attempt to become the leader.
  It is necessary to call this function when starting a new cluster as a
  brand new Ra server (node) will not automatically enter the pre-vote state.
  This does not apply to recovering (previously started) servers: they will
  enter the pre-vote state and proceed to participate in an election on boot.
 </p>

<h3 class="function"><a name="trigger_election-2">trigger_election/2</a></h3>
<div class="spec">
<p><pre>trigger_election(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, Timeout :: timeout()) -&gt;
                    ok</pre></p>
<p> </p>
</div><p>Same as <code>trigger_election/2</code> but also accepts a timeout.</p>

<h3 class="function"><a name="leave_and_terminate-3">leave_and_terminate/3</a></h3>
<div class="spec">
<p><pre>leave_and_terminate(System :: atom(),
                    ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                    ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                       ok | timeout |
                       {error, noproc | system_not_started}</pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to and to remove<br>
<tt>ServerId</tt>: the ra server to remove<br>
</p>
</div><p>A safe way to remove an active server from its cluster.
  The command is added to the log by the <code>ServerRef</code> node.
  Use this to decommission a node that's unable to start
  or is permanently lost.</p>
<p><b>See also:</b> <a href="#leave_and_terminate-3">leave_and_terminate/3</a>.</p>

<h3 class="function"><a name="leave_and_terminate-4">leave_and_terminate/4</a></h3>
<div class="spec">
<p><pre>leave_and_terminate(System :: atom(),
                    ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                    ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                    Timeout :: timeout()) -&gt;
                       ok | timeout |
                       {error, noproc | system_not_started}</pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to and to remove<br>
<tt>ServerId</tt>: the ra server to remove<br>
<tt>Timeout</tt>: timeout to use<br>
</p>
</div><p>Same as <code>leave_and_terminate/2</code> but also accepts a timeout.</p>
<p><b>See also:</b> <a href="#leave_and_terminate-2">leave_and_terminate/2</a>.</p>

<h3 class="function"><a name="leave_and_delete_server-3">leave_and_delete_server/3</a></h3>
<div class="spec">
<p><pre>leave_and_delete_server(System :: atom(),
                        ServerRef ::
                            <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                        ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                           ok | timeout | {error, noproc}</pre></p>
<p><tt>System</tt>: the system identifier<br>
<tt>ServerRef</tt>: the ra server to send the command to and to remove<br>
<tt>ServerId</tt>: the ra server to force remove<br>
</p>
</div><p>A safe way to remove an active server from its cluster.
  The server will be force removed after a membership transition command was
  added to the log.
  The command is added to the log by the <code>ServerRef</code> node.
  Use this to decommission a node that's unable to start
  or is permanently lost.</p>
<p><b>See also:</b> <a href="#leave_and_delete_server-3">leave_and_delete_server/3</a>.</p>

<h3 class="function"><a name="leave_and_delete_server-4">leave_and_delete_server/4</a></h3>
<div class="spec">
<p><pre>leave_and_delete_server(System :: atom(),
                        ServerRef ::
                            <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                        ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                        Timeout :: timeout()) -&gt;
                           ok | timeout | {error, noproc}</pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to and to remove<br>
<tt>ServerId</tt>: the ra server to force remove<br>
<tt>Timeout</tt>: timeout to use<br>
</p>
</div><p>Same as <code>leave_and_delete_server/2</code> but also accepts a timeout.</p>
<p><b>See also:</b> <a href="#leave_and_delete_server-2">leave_and_delete_server/2</a>.</p>

<h3 class="function"><a name="new_uid-1">new_uid/1</a></h3>
<div class="spec">
<p><tt>new_uid(Source) -&gt; any()</tt></p>
<p> </p>
</div><p>generates a random uid using the provided source material for the first
  6 characters.</p>

<h3 class="function"><a name="overview-0">overview/0</a></h3>
<div class="spec">
<p><pre>overview() -&gt; map() | system_not_started</pre></p>
<p> </p>
</div><p>Returns a map of overview data of the default Ra system on the current Erlang
  node.
  DEPRECATED: user overview/1</p>

<h3 class="function"><a name="overview-1">overview/1</a></h3>
<div class="spec">
<p><pre>overview(System :: atom()) -&gt; map() | system_not_started</pre></p>
<p> </p>
</div><p>Returns a map of overview data of the Ra system on the current Erlang
  node.</p>

<h3 class="function"><a name="process_command-3">process_command/3</a></h3>
<div class="spec">
<p><pre>process_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                Command :: term(),
                Timeout :: timeout()) -&gt;
                   {ok, Reply :: term(), Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} |
                   {error, term()} |
                   {timeout, <a href="#type-ra_server_id">ra_server_id()</a>}</pre></p>
<p><tt>ServerId</tt>: the server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
<tt>Timeout</tt>: the time to wait before returning {timeout, ServerId}<br>
</p>
</div><p><p>Submits a command to a ra server. Returns after the command has
  been applied to the Raft state machine. If the state machine returned a
  response it is included in the second element of the response tuple.
  If no response was returned the second element is the atom <code>noreply</code>.  
If the server receiving the command isn't the current leader it will  
redirect the call to the leader (if known) or hold on to the command until  
a leader is known. The leader's server id is returned as the 3rd element  
of the success reply tuple.</p>
 
  If there is no majority of Ra servers online, this function will return
  a timeout.
 </p>

<h3 class="function"><a name="process_command-2">process_command/2</a></h3>
<div class="spec">
<p><pre>process_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                Command :: term()) -&gt;
                   {ok, Reply :: term(), Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} |
                   {error, term()} |
                   {timeout, <a href="#type-ra_server_id">ra_server_id()</a>}</pre></p>
<p><tt>ServerId</tt>: the server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
</p>
</div><p>Same as <code>process_command/3</code> with the default timeout of 5000 ms.</p>

<h3 class="function"><a name="pipeline_command-4">pipeline_command/4</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 Command :: term(),
                 Correlation ::
                     <a href="ra_server.html#type-command_correlation">ra_server:command_correlation()</a> |
                     no_correlation,
                 Priority :: normal | low) -&gt;
                    ok</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
<tt>Correlation</tt>: a correlation identifier to be included to receive an
         async notification after the command is applied to the state machine. If the
         Correlation is set to <code>no_correlation</code> then no notifications will be sent.<br>
<tt>Priority</tt>: command priority. <code>low</code> priority commands will be held back
         and appended to the Raft log in batches. NB: A <code>normal</code> priority command sent
         from the same process can overtake a low priority command that was
         sent before. There is no high priority.
         Only use priority level of <code>low</code> with commands that
         do not rely on total execution ordering.<br>
</p>
</div><p><p>Submits a command to the ra server using a gen_statem:cast, passing  
an optional process-scoped term as correlation identifier.  
A correlation id can be included  
to implement reliable async interactions with the ra system. The calling  
process can retain a map of commands that have not yet been applied to the  
state machine successfully and resend them if a notification is not received  
withing some time window.  
When the submitted command(s) is applied to the state machine, the ra server will send  
the calling process a ra_event of the following structure:</p>
 
  <p><code>{ra_event, CurrentLeader, {applied, [{Correlation, Reply}]}}</code></p>
 
  <p>Ra will batch notification and thus return a list of correlation  
and result tuples.</p>
 
  <p>If the receiving ra server is not the cluster leader, a ra event of the following  
structure will be returned informing the caller that it cannot process the  
message. The message will include the current cluster leader, if one is known:</p>
 
  <p><code>{ra_event, FromId, {rejected, {not_leader, Leader | undefined, Correlation}}}</code></p>
 
  <p>The caller must then redirect the command for the correlation identifier to  
the correct ra server: the leader.</p>
 
  <p>If instead the atom <code>no_correlation</code> is passed for the correlation argument,  
the calling process will not receive any notification of command processing  
success or otherwise.</p>
 
  This is the least reliable way to interact with a ra system ("fire and forget")
  and should only be used if the command is of little importance to the application.
 </p>

<h3 class="function"><a name="pipeline_command-3">pipeline_command/3</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 Command :: term(),
                 Correlation ::
                     <a href="ra_server.html#type-command_correlation">ra_server:command_correlation()</a> |
                     no_correlation) -&gt;
                    ok</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
<tt>Correlation</tt>: a correlation identifier to be included to receive an
         async notification after the command is applied to the state machine.<br>
</p>
</div><p>Same as <code>pipeline_command/4</code> but uses a hardcoded priority of <code>low</code>.</p>
<p><b>See also:</b> <a href="#pipeline_command-4">pipeline_command/4</a>.</p>

<h3 class="function"><a name="pipeline_command-2">pipeline_command/2</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, Command :: term()) -&gt;
                    ok</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
</p>
</div><p>Sends a command to the ra server using a gen_statem:cast without
  any correlation identifier.
  Effectively the same as
  <code>ra:pipeline_command(ServerId, Command, low, no_correlation)</code>
  This is the least reliable way to interact with a ra system ("fire and forget")
  and should only be used for commands that are of little importance
  and/or where waiting for a response is prohibitively slow.</p>
<p><b>See also:</b> <a href="#pipeline_command-4">pipeline_command/4</a>.</p>

<h3 class="function"><a name="local_query-2">local_query/2</a></h3>
<div class="spec">
<p><pre>local_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
               <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                  Reply :: term()})</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
</p>
</div><p>Query the machine state on any available server.
  This allows you to run the QueryFun over the server machine state and
  return the result. Any ra server can be addressed and will returns its local
  state at the time of querying.
  This can return stale results, including infinitely stale ones.</p>

<h3 class="function"><a name="local_query-3">local_query/3</a></h3>
<div class="spec">
<p><pre>local_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
            QueryFun :: <a href="#type-query_fun">query_fun()</a>,
            Timeout :: timeout()) -&gt;
               <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                  Reply :: term()}) |
               {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, Reply :: term()}, not_known}</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
<tt>Timeout</tt>: the timeout to use<br>
</p>
</div><p>Same as <code>local_query/2</code> but accepts a custom timeout.</p>
<p><b>See also:</b> <a href="#local_query-2">local_query/2</a>.</p>

<h3 class="function"><a name="leader_query-2">leader_query/2</a></h3>
<div class="spec">
<p><pre>leader_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
             QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
                <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                   Reply :: term()}) |
                {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, Reply :: term()}, not_known}</pre></p>
<p><tt>ServerId</tt>: the ra server id(s) to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
</p>
</div><p>Query the machine state on the current leader node.
  This function works like local_query, but redirects to the current
  leader node.
  The leader state may be more up-to-date compared to local state of some followers.
  This function may still return stale results as it reads the current state
  and does not wait for commands to be applied.</p>

<h3 class="function"><a name="leader_query-3">leader_query/3</a></h3>
<div class="spec">
<p><pre>leader_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
             QueryFun :: <a href="#type-query_fun">query_fun()</a>,
             Timeout :: timeout()) -&gt;
                <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                   Reply :: term()}) |
                {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, Reply :: term()}, not_known}</pre></p>
<p><tt>ServerId</tt>: the ra server id(s) to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
<tt>Timeout</tt>: the timeout to use<br>
</p>
</div><p>Same as <code>leader_query/2</code> but accepts a custom timeout.</p>
<p><b>See also:</b> <a href="#leader_query-2">leader_query/2</a>.</p>

<h3 class="function"><a name="consistent_query-2">consistent_query/2</a></h3>
<div class="spec">
<p><pre>consistent_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                 QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
                    <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>(Reply ::
                                                          term())</pre></p>
<p><tt>ServerId</tt>: the ra server id(s) to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
</p>
</div><p>Query the state machine with a consistency guarantee.
  This allows the caller to query the state machine on the leader node with
  an additional heartbeat to check that the node is still the leader.
  Consistency guarantee is that the query will return result containing
  at least all changes, committed before this query is issued.
  This may include changes which were committed while the query is running.</p>

<h3 class="function"><a name="consistent_query-3">consistent_query/3</a></h3>
<div class="spec">
<p><pre>consistent_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                 QueryFun :: <a href="#type-query_fun">query_fun()</a>,
                 Timeout :: timeout()) -&gt;
                    <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>(Reply ::
                                                          term())</pre></p>
<p><tt>ServerId</tt>: the ra server id(s) to send the query to<br>
<tt>QueryFun</tt>: the query function to run<br>
<tt>Timeout</tt>: the timeout to use<br>
</p>
</div><p>Same as <code>consistent_query/2</code> but accepts a custom timeout.</p>
<p><b>See also:</b> <a href="#consistent_query-2">consistent_query/2</a>.</p>

<h3 class="function"><a name="members-1">members/1</a></h3>
<div class="spec">
<p><pre>members(ServerId ::
            <a href="#type-ra_server_id">ra_server_id()</a> |
            [<a href="#type-ra_server_id">ra_server_id()</a>] |
            {local, <a href="#type-ra_server_id">ra_server_id()</a>}) -&gt;
           <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>])</pre></p>
<p><tt>ServerId</tt>: the Ra server(s) to send the query to<br>
</p>
</div><p><p>Returns a list of cluster members</p>
 
  <p>Except if <code>{local, ServerId}</code> is passed, the query is sent to the specified  
server which may redirect it to the leader if it is a follower. It may  
timeout if there is currently no leader (i.e. an election is in progress).</p>
 
  With <code>{local, ServerId}</code>, the query is always handled by the specified
  server. It means the returned list might be out-of-date compared to what the
  leader would have returned.
 </p>

<h3 class="function"><a name="members-2">members/2</a></h3>
<div class="spec">
<p><pre>members(ServerId ::
            <a href="#type-ra_server_id">ra_server_id()</a> |
            [<a href="#type-ra_server_id">ra_server_id()</a>] |
            {local, <a href="#type-ra_server_id">ra_server_id()</a>},
        Timeout :: timeout()) -&gt;
           <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>])</pre></p>
<p><tt>ServerId</tt>: the Ra server(s) to send the query to<br>
<tt>Timeout</tt>: the timeout to use<br>
</p>
</div><p><p>Returns a list of cluster members</p>
 
  <p>Except if <code>{local, ServerId}</code> is passed, the query is sent to the specified  
server which may redirect it to the leader if it is a follower. It may  
timeout if there is currently no leader (i.e. an election is in progress).</p>
 
  With <code>{local, ServerId}</code>, the query is always handled by the specified
  server. It means the returned list might be out-of-date compared to what the
  leader would have returned.
 </p>

<h3 class="function"><a name="initial_members-1">initial_members/1</a></h3>
<div class="spec">
<p><pre>initial_members(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                   <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>] |
                                                     error)</pre></p>
<p> </p>
</div>

<h3 class="function"><a name="initial_members-2">initial_members/2</a></h3>
<div class="spec">
<p><pre>initial_members(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a> | [<a href="#type-ra_server_id">ra_server_id()</a>],
                Timeout :: timeout()) -&gt;
                   <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>] |
                                                     error)</pre></p>
<p> </p>
</div>

<h3 class="function"><a name="transfer_leadership-2">transfer_leadership/2</a></h3>
<div class="spec">
<p><pre>transfer_leadership(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                    TargetServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                       ok | already_leader |
                       {error, term()} |
                       {timeout, <a href="#type-ra_server_id">ra_server_id()</a>}</pre></p>
<p> </p>
</div><p>Transfers leadership from the leader to a follower.
  Returns <code>already_leader</code> if the transfer targer is already the leader.</p>

<h3 class="function"><a name="aux_command-2">aux_command/2</a></h3>
<div class="spec">
<p><pre>aux_command(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>, Cmd :: term()) -&gt; term()</pre></p>
<p> </p>
</div>

<h3 class="function"><a name="cast_aux_command-2">cast_aux_command/2</a></h3>
<div class="spec">
<p><pre>cast_aux_command(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>, Cmd :: term()) -&gt; ok</pre></p>
<p> </p>
</div>

<h3 class="function"><a name="register_external_log_reader-1">register_external_log_reader/1</a></h3>
<div class="spec">
<p><pre>register_external_log_reader(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                                <a href="ra_log_reader.html#type-state">ra_log_reader:state()</a></pre></p>
<p> </p>
</div><p>Registers an external log reader. ServerId needs to be local to the node.
  Returns an initiated ra_log_reader:state() state.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
